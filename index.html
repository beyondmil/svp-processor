<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVP Data Processor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="text/babel">
        const { useState } = React;
        
        const Upload = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
        );
        
        const Download = ({ size = 24, className = "" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
        );

        const SVPDataProcessor = () => {
          const [inputMethod, setInputMethod] = useState('manual');
          const [batchData, setBatchData] = useState('');
          const [batchDelimiter, setBatchDelimiter] = useState('tab');
          const [velocitySource, setVelocitySource] = useState('sound');
          const [manualParse, setManualParse] = useState(false);
          const [noCalculatedSOS, setNoCalculatedSOS] = useState(false);
          const [columnMapping, setColumnMapping] = useState({
            depth: '2',
            temperature: '3',
            velocity: '1'
          });
          const [detectedHeaders, setDetectedHeaders] = useState([]);
          const [fileContent, setFileContent] = useState('');
          const [formData, setFormData] = useState({
            jobNo: '',
            project: '',
            client: '',
            dateTime: '',
            area: '',
            location: '',
            vessel: '',
            instrument: ''
          });
          
          const [manualData, setManualData] = useState([
            { depth: '', temperature: '', velocity: '', depthUnit: 'm', tempUnit: 'C', velUnit: 'm/s' }
          ]);
          
          const [uploadedFile, setUploadedFile] = useState(null);

          const convertDepth = (value, fromUnit) => {
            const conversions = { 'm': 1, 'ft': 0.3048, 'fathom': 1.8288 };
            return parseFloat(value) * conversions[fromUnit];
          };

          const convertTemperature = (value, fromUnit) => {
            const val = parseFloat(value);
            if (fromUnit === 'C') return val;
            if (fromUnit === 'F') return (val - 32) * 5/9;
            if (fromUnit === 'K') return val - 273.15;
            return val;
          };

          const convertVelocity = (value, fromUnit) => {
            const conversions = { 'm/s': 1, 'ft/s': 0.3048, 'km/h': 0.277778, 'knots': 0.514444 };
            return parseFloat(value) * conversions[fromUnit];
          };

          const addDataRow = () => {
            setManualData([...manualData, { 
              depth: '', temperature: '', velocity: '', 
              depthUnit: 'm', tempUnit: 'C', velUnit: 'm/s' 
            }]);
          };

          const removeDataRow = (index) => {
            if (manualData.length > 1) {
              setManualData(manualData.filter((_, i) => i !== index));
            }
          };

          const updateManualData = (index, field, value) => {
            const newData = [...manualData];
            newData[index][field] = value;
            setManualData(newData);
          };

          const parseBatchData = (text, delimiter = 'tab') => {
            const lines = text.trim().split('\n').filter(line => line.trim());
            
            let delimiterPattern;
            switch(delimiter) {
              case 'comma': delimiterPattern = /,/; break;
              case 'semicolon': delimiterPattern = /;/; break;
              case 'dash': delimiterPattern = /-/; break;
              case 'underscore': delimiterPattern = /_/; break;
              case 'tab':
              default: delimiterPattern = /[\t\s]+/; break;
            }
            
            const parsed = lines.map(line => {
              const parts = line.split(delimiterPattern).filter(p => p.trim());
              if (parts.length >= 3) {
                return {
                  depth: parseFloat(parts[0]),
                  temperature: parseFloat(parts[1]),
                  velocity: parseFloat(parts[2])
                };
              }
              return null;
            }).filter(row => row !== null && !isNaN(row.depth) && !isNaN(row.temperature) && !isNaN(row.velocity));
            
            return parsed;
          };

          const findDataStartLine = (lines) => {
            for (let i = 0; i < lines.length - 10; i++) {
              const line = lines[i];
              const parts = line.split('\t').filter(p => p.trim());
              
              if (parts.length >= 4) {
                let consistentCount = 0;
                const expectedColumns = parts.length;
                
                for (let j = i + 1; j < i + 6 && j < lines.length; j++) {
                  const nextParts = lines[j].split('\t').filter(p => p.trim());
                  if (nextParts.length === expectedColumns) {
                    const numericCols = nextParts.filter(p => !isNaN(parseFloat(p))).length;
                    if (numericCols >= 3) {
                      consistentCount++;
                    }
                  }
                }
                
                if (consistentCount >= 4) {
                  const hasLetters = /[a-zA-Z]/.test(line);
                  if (hasLetters) {
                    return i;
                  } else {
                    return Math.max(0, i - 1);
                  }
                }
              }
            }
            return -1;
          };

          const parseInstrumentData = (text, velocityType = 'sound', manualColumns = null) => {
            const lines = text.split('\n');
            const dataStartIndex = findDataStartLine(lines);
            
            if (dataStartIndex === -1) {
              alert('Could not detect data section. Please enable Manual Parse.');
              return [];
            }
            
            const headerLine = lines[dataStartIndex];
            const isHeader = /[a-zA-Z]/.test(headerLine);
            const headers = isHeader ? headerLine.split('\t').map(h => h.trim()) : [];
            setDetectedHeaders(headers);
            
            const actualDataStart = isHeader ? dataStartIndex + 1 : dataStartIndex;
            let depthCol, tempCol, velCol;
            
            if (manualColumns) {
              depthCol = parseInt(manualColumns.depth);
              tempCol = parseInt(manualColumns.temperature);
              velCol = parseInt(manualColumns.velocity);
            } else if (headers.length > 0) {
              depthCol = headers.findIndex(h => 
                h.toLowerCase().includes('pressure') || h.toLowerCase().includes('depth')
              );
              tempCol = headers.findIndex(h => 
                h.toLowerCase().includes('temperature') || h.toLowerCase().includes('temp')
              );
              
              if (velocityType === 'sound') {
                velCol = headers.findIndex(h => 
                  h.toLowerCase().includes('sound velocity') || 
                  (h.toLowerCase().includes('velocity') && !h.toLowerCase().includes('calc'))
                );
              } else {
                velCol = headers.findIndex(h => 
                  h.toLowerCase().includes('calc') && h.toLowerCase().includes('sos')
                );
              }
              
              if (depthCol === -1) depthCol = 2;
              if (tempCol === -1) tempCol = 3;
              if (velCol === -1) velCol = velocityType === 'sound' ? 1 : 7;
            } else {
              depthCol = 2;
              tempCol = 3;
              velCol = 1;
            }
            
            const dataLines = lines.slice(actualDataStart).filter(line => line.trim());
            
            const allData = dataLines.map(line => {
              const parts = line.split('\t').map(p => p.trim());
              if (parts.length >= Math.max(depthCol, tempCol, velCol) + 1) {
                const depth = parseFloat(parts[depthCol]);
                const temperature = parseFloat(parts[tempCol]);
                const velocity = parseFloat(parts[velCol]);
                
                return { timestamp: parts[0] || '', depth, temperature, velocity };
              }
              return null;
            }).filter(row => row !== null && !isNaN(row.depth) && !isNaN(row.temperature) && !isNaN(row.velocity));
            
            return filterConsistentDepthData(allData);
          };

          const filterConsistentDepthData = (data) => {
            if (data.length === 0) return [];
            
            let startIndex = 0;
            const threshold = 0.5;
            
            for (let i = 0; i < data.length - 5; i++) {
              let isConsistentAscending = true;
              for (let j = i; j < i + 4 && j < data.length - 1; j++) {
                if (data[j + 1].depth <= data[j].depth + threshold) {
                  isConsistentAscending = false;
                  break;
                }
              }
              
              if (isConsistentAscending) {
                startIndex = i;
                break;
              }
            }
            
            let peakIndex = startIndex;
            let maxDepth = data[startIndex].depth;
            
            for (let i = startIndex + 1; i < data.length; i++) {
              if (data[i].depth > maxDepth) {
                maxDepth = data[i].depth;
                peakIndex = i;
              }
            }
            
            let endIndex = data.length - 1;
            
            for (let i = data.length - 1; i > peakIndex + 5; i--) {
              let isConsistentDescending = true;
              for (let j = i; j > i - 4 && j > peakIndex; j--) {
                if (data[j - 1].depth <= data[j].depth - threshold) {
                  isConsistentDescending = false;
                  break;
                }
              }
              
              if (isConsistentDescending) {
                endIndex = i;
                break;
              }
            }
            
            return data.slice(startIndex, endIndex + 1).map(row => ({
              depth: row.depth,
              temperature: row.temperature,
              velocity: row.velocity
            }));
          };

          const detectDownwardUpward = (data) => {
            if (data.length === 0) return { downward: [], upward: [] };
            
            let turningPoint = 0;
            
            for (let i = 0; i < data.length - 1; i++) {
              if (data[i + 1].depth < data[i].depth) {
                turningPoint = i;
                break;
              }
            }
            
            if (turningPoint === 0 && data.length > 1 && data[1].depth >= data[0].depth) {
              turningPoint = data.length - 1;
            }
            
            const downward = data.slice(0, turningPoint + 1);
            const upward = data.slice(turningPoint + 1);
            
            return { downward, upward };
          };

          const separateDownwardUpward = (data) => {
            if (data[0].depthUnit) {
              const convertedData = data.map(row => ({
                depth: convertDepth(row.depth, row.depthUnit),
                temperature: convertTemperature(row.temperature, row.tempUnit),
                velocity: convertVelocity(row.velocity, row.velUnit)
              }));
              return detectDownwardUpward(convertedData);
            }
            return detectDownwardUpward(data);
          };

          const handleFileUpload = (event) => {
            const file = event.target.files[0];
            if (file) {
              setUploadedFile(file);
              const reader = new FileReader();
              reader.onload = (e) => {
                const text = e.target.result;
                setFileContent(text);
                
                const hasMultipleColumns = text.split('\n').some(line => {
                  const parts = line.split('\t');
                  return parts.length >= 4;
                });
                
                if (hasMultipleColumns) {
                  const parsed = parseInstrumentData(text, velocitySource, manualParse ? columnMapping : null);
                  
                  if (parsed.length > 0) {
                    alert(`Parsed ${parsed.length} valid data points from instrument file`);
                    const converted = parsed.map(row => ({
                      depth: row.depth.toString(),
                      temperature: row.temperature.toString(),
                      velocity: row.velocity.toString(),
                      depthUnit: 'm',
                      tempUnit: 'C',
                      velUnit: 'm/s'
                    }));
                    setManualData(converted);
                  } else {
                    alert('No valid data found. Try enabling Manual Parse and setting column numbers.');
                  }
                } else {
                  const parsed = parseBatchData(text, batchDelimiter);
                  if (parsed.length > 0) {
                    const converted = parsed.map(row => ({
                      depth: row.depth.toString(),
                      temperature: row.temperature.toString(),
                      velocity: row.velocity.toString(),
                      depthUnit: 'm',
                      tempUnit: 'C',
                      velUnit: 'm/s'
                    }));
                    setManualData(converted);
                  }
                }
              };
              reader.readAsText(file);
            }
          };

          const reprocessFile = () => {
            if (!fileContent) return;
            
            const parsed = parseInstrumentData(fileContent, velocitySource, manualParse ? columnMapping : null);
            
            if (parsed.length > 0) {
              alert(`Re-parsed ${parsed.length} valid data points`);
              const converted = parsed.map(row => ({
                depth: row.depth.toString(),
                temperature: row.temperature.toString(),
                velocity: row.velocity.toString(),
                depthUnit: 'm',
                tempUnit: 'C',
                velUnit: 'm/s'
              }));
              setManualData(converted);
            } else {
              alert('No valid data found with current settings.');
            }
          };

          const generateExcel = async () => {
            try {
              let validData = [];
              
              if (inputMethod === 'batch') {
                validData = parseBatchData(batchData, batchDelimiter);
                if (validData.length === 0) {
                  alert('Please enter valid batch data');
                  return;
                }
              } else {
                validData = manualData.filter(row => row.depth && row.temperature && row.velocity);
                if (validData.length === 0) {
                  alert('Please enter at least one complete data row');
                  return;
                }
              }

              const { downward, upward } = separateDownwardUpward(validData);

              alert('Fetching template from GitHub...');
              const templateUrl = './public/templates/SVP_Report_Landscape.xlsx';
              
              const response = await fetch(templateUrl);
              if (!response.ok) {
                throw new Error('Failed to fetch template');
              }
              
              const arrayBuffer = await response.arrayBuffer();
              const workbook = XLSX.read(arrayBuffer, { type: 'array', cellStyles: true });

              const svpSheet = workbook.Sheets['SVP'];
              
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.jobNo ? `: ${formData.jobNo}` : '']], { origin: 'B1' });
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.project ? `: ${formData.project}` : '']], { origin: 'B2' });
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.client ? `: ${formData.client}` : '']], { origin: 'B3' });
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.dateTime ? `: ${formData.dateTime}` : '']], { origin: 'B4' });
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.area ? `: ${formData.area}` : '']], { origin: 'E1' });
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.location ? `: ${formData.location}` : '']], { origin: 'E2' });
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.vessel ? `: ${formData.vessel}` : '']], { origin: 'E3' });
              XLSX.utils.sheet_add_aoa(svpSheet, [[formData.instrument ? `: ${formData.instrument}` : '']], { origin: 'E4' });

              const maxRows = Math.max(downward.length, upward.length);
              
              const downwardData = downward.map(row => [
                parseFloat(row.depth).toFixed(2),
                parseFloat(row.temperature).toFixed(2),
                parseFloat(row.velocity).toFixed(2)
              ]);
              XLSX.utils.sheet_add_aoa(svpSheet, downwardData, { origin: 'A8' });

              const upwardData = upward.map(row => [
                parseFloat(row.depth).toFixed(2),
                parseFloat(row.temperature).toFixed(2),
                parseFloat(row.velocity).toFixed(2)
              ]);
              XLSX.utils.sheet_add_aoa(svpSheet, upwardData, { origin: 'D8' });

              const lastDataRow = 7 + maxRows;
              const formulaRow = lastDataRow + 1;
              
              svpSheet[`B${formulaRow}`] = { f: `AVERAGE(B8:B${lastDataRow})` };
              svpSheet[`C${formulaRow}`] = { f: `AVERAGE(C8:C${lastDataRow})` };
              svpSheet[`E${formulaRow}`] = { f: `AVERAGE(E8:E${lastDataRow})` };
              svpSheet[`F${formulaRow}`] = { f: `AVERAGE(F8:F${lastDataRow})` };
              
              svpSheet[`B${formulaRow + 1}`] = { f: `MIN(B8:B${lastDataRow})` };
              svpSheet[`C${formulaRow + 1}`] = { f: `MIN(C8:C${lastDataRow})` };
              svpSheet[`E${formulaRow + 1}`] = { f: `MIN(E8:E${lastDataRow})` };
              svpSheet[`F${formulaRow + 1}`] = { f: `MIN(F8:F${lastDataRow})` };
              
              svpSheet[`B${formulaRow + 2}`] = { f: `MAX(B8:B${lastDataRow})` };
              svpSheet[`C${formulaRow + 2}`] = { f: `MAX(C8:C${lastDataRow})` };
              svpSheet[`E${formulaRow + 2}`] = { f: `MAX(E8:E${lastDataRow})` };
              svpSheet[`F${formulaRow + 2}`] = { f: `MAX(F8:F${lastDataRow})` };
              
              svpSheet[`B${formulaRow + 3}`] = { f: `STDEV(B8:B${lastDataRow})` };
              svpSheet[`C${formulaRow + 3}`] = { f: `STDEV(C8:C${lastDataRow})` };
              svpSheet[`E${formulaRow + 3}`] = { f: `STDEV(E8:E${lastDataRow})` };
              svpSheet[`F${formulaRow + 3}`] = { f: `STDEV(F8:F${lastDataRow})` };
              
              svpSheet[`C${formulaRow + 4}`] = { f: `AVERAGE(C${formulaRow},F${formulaRow})` };

              const rawSheet = workbook.Sheets['RAW'];
              const allRawData = validData.map(row => [row.depth, row.temperature, row.velocity]);
              XLSX.utils.sheet_add_aoa(rawSheet, allRawData, { origin: 'A1' });

              const svpRange = XLSX.utils.decode_range(svpSheet['!ref']);
              svpRange.e.r = Math.max(svpRange.e.r, formulaRow + 4);
              svpSheet['!ref'] = XLSX.utils.encode_range(svpRange);
              
              const rawRange = XLSX.utils.decode_range(rawSheet['!ref']);
              rawRange.e.r = Math.max(rawRange.e.r, allRawData.length);
              rawSheet['!ref'] = XLSX.utils.encode_range(rawRange);

              XLSX.writeFile(workbook, `SVP_${formData.jobNo || 'Data'}_${new Date().toISOString().split('T')[0]}.xlsx`);
              
              alert('Excel file generated successfully!');
            } catch (error) {
              console.error('Error generating Excel:', error);
              alert(`Error: ${error.message}`);
            }
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
              <div className="max-w-6xl mx-auto">
                <div className="bg-white rounded-lg shadow-xl p-8">
                  <h1 className="text-3xl font-bold text-indigo-900 mb-6">SVP Data Processor</h1>
                  
                  <div className="mb-8">
                    <h2 className="text-xl font-semibold text-gray-800 mb-4">Document Identity</h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <div className="space-y-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Job No.</label>
                          <input type="text" value={formData.jobNo} onChange={(e) => setFormData({...formData, jobNo: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Project</label>
                          <input type="text" value={formData.project} onChange={(e) => setFormData({...formData, project: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Client</label>
                          <input type="text" value={formData.client} onChange={(e) => setFormData({...formData, client: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Date/Time</label>
                          <input type="datetime-local" value={formData.dateTime} onChange={(e) => setFormData({...formData, dateTime: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                      </div>
                      
                      <div className="space-y-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Area</label>
                          <input type="text" value={formData.area} onChange={(e) => setFormData({...formData, area: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Location</label>
                          <input type="text" value={formData.location} onChange={(e) => setFormData({...formData, location: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Vessel</label>
                          <input type="text" value={formData.vessel} onChange={(e) => setFormData({...formData, vessel: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Instrument</label>
                          <input type="text" value={formData.instrument} onChange={(e) => setFormData({...formData, instrument: e.target.value})} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="mb-6">
                    <h2 className="text-xl font-semibold text-gray-800 mb-4">Data Input Method</h2>
                    <div className="flex gap-4">
                      <button onClick={() => setInputMethod('manual')} className={`px-6 py-3 rounded-lg font-medium ${inputMethod === 'manual' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-700'}`}>Manual Entry</button>
                      <button onClick={() => setInputMethod('batch')} className={`px-6 py-3 rounded-lg font-medium ${inputMethod === 'batch' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-700'}`}>Batch Entry</button>
                      <button onClick={() => setInputMethod('upload')} className={`flex items-center gap-2 px-6 py-3 rounded-lg font-medium ${inputMethod === 'upload' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-700'}`}><Upload size={20} />Upload File</button>
                    </div>
                  </div>

                  {inputMethod === 'manual' && (
                    <div className="mb-6">
                      <h2 className="text-xl font-semibold text-gray-800 mb-4">Manual Data Entry</h2>
                      <button onClick={addDataRow} className="mb-4 px-6 py-2 bg-green-600 text-white rounded-lg">+ Add Row</button>
                    </div>
                  )}

                  <div className="flex justify-center">
                    <button onClick={generateExcel} className="flex items-center gap-2 px-8 py-4 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 font-bold text-lg shadow-lg"><Download size={24} />Generate Excel File</button>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<SVPDataProcessor />, document.getElementById('root'));
    </script>
</body>
</html>